# ✅ StructMOGWO 全面梳理：准备写代码版本
## 🧠 目标任务简述：

> 解决 **多目标、离散影响力最大化（DMOIM）问题**，优化节点种子集，使其在传播范围最大化、成本最小化、公平性等多个目标上逼近 Pareto 前沿。
## 🧱 1. 解的表示

- 每只狼表示为一个种子节点集合：
  ```python
  wolf.Position = set([v1, v2, ..., vk])  # k = budget
  ```
---

## 🌱 2. 初始化策略

- 结构指标提前计算：
- 初始化种群：
  - 50% 个体使用结构启发式（closeness + degree 排名前 k）；
  - 50% 个体使用随机采样；
- 同时预处理指标归一化：
---

## 🧠 3. 主迭代过程核心模块

### 🎯 每轮迭代结构如下：

```python
for t in range(max_iter):
    # 1. 更新适应度
    for wolf in population:
        wolf.Cost = multi_obj_eval(wolf.Position)

    # 2. 更新 archive（非支配解 + grid）
    update_archive(population)

    # 3. 选 Leader（α, β, δ）
    α, β, δ = select_leaders(archive)

    # 4. 更新每只狼（结构感知）
    for wolf in population:
        # 4.1 构造 base
        base = wolf.Position ∩ α ∩ β ∩ δ

        # 4.2 构造候选池
        strategy = random.choices(["global", "leader_neighbor"], weights=[0.6, 0.4])[0]
        candidate_pool = generate_candidates(strategy, base, wolf.Position, α, β, δ, G)

        # 4.3 使用结构评分函数（closeness + degree，动态权重）
        new_nodes = select_candidate_nodes(candidate_pool, budget - len(base), t, max_iter)

        # 4.4 合并更新
        new_position = base ∪ new_nodes
        wolf.Position = new_position

        # 4.5 扰动（小概率）
        p_perturb = 0.05 + 0.25 * (t / max_iter)
        if random.random() < p_perturb:
            wolf.Position = apply_perturbation(wolf.Position, closeness)

    # 5. archive 更新 & HV记录
    update_archive(population)
```

---

## 🧩 4. 模块细节说明

### 🔹 4.1 结构评分函数（动态）

```python
def node_score(v, t, max_iter):
    w1 = 0.8 - 0.6 * (t / max_iter)
    w2 = 1 - w1
    return w1 * closeness_norm[v] + w2 * degree_norm[v]
```
---

### 🔹 4.2 候选池生成

```python
def generate_candidates(strategy, base, current, α, β, δ, G):
    if strategy == 'global':
        return set(G.nodes()) - base - current
    else:
        leaders = α | β | δ
        non_base = leaders - base
        neighbors = set()
        for node in non_base:
            neighbors.update(G.neighbors(node))
        return (non_base | neighbors) - base - current
```

---

### 🔹 4.3 节点选择逻辑

```python
def select_candidate_nodes(candidate_pool, k_remain, t, max_iter):
    scored = sorted(candidate_pool, key=lambda v: node_score(v, t, max_iter), reverse=True)
    return set(scored[:k_remain])
```

---

### 🔹 4.4 扰动机制（结构跳跃）

```python
def apply_perturbation(position, closeness):
    out_node = random.choice(list(position))
    position.remove(out_node)

    candidate_pool = set(closeness.keys()) - position
    far_node = max(candidate_pool, key=lambda v: closeness[v])
    position.add(far_node)

    return position
```

---

## 📦 5. Archive 管理（Pareto + Grid）

- 每轮更新：
  - 将所有狼和 archive 合并；
  - 去除被支配解；
  - 使用 Grid 分布评估 Hypervolume 密度；
  - 若超出容量，用 γ 压缩密集区域的解；
  - 记录 HV 曲线用于评估收敛性。

---

## 📈 6. 多目标适应度函数（可自定义）

```python
def multi_obj_eval(seed_set):
    spread = run_IC(seed_set)  # 可替换传播模型
    cost = sum(node_cost[v] for v in seed_set)
    fairness = compute_fairness(seed_set)
    return [spread, cost, fairness]
```
---

## ✅ 7. 总体设计原则：

| 维度 | 描述 |
|------|------|
| 多样性控制 | 候选池策略 + 动态扰动 |
| 跳跃可调 | base 长度决定更新强度 |
| 结构解释性 | 更新节点具有传播意义 |
| 多目标驱动 | α/β/δ 不同引导方向 |
| 可扩展性 | 可接入更多传播模型 / 目标 |

selectleader():
We divide the 2D objective space into three triangular subregions representing different preference zones: one prioritizing influence spread, one for fairness, and one for trade-off. For each region, we select one non-dominated solution as a leader by combining normalized location and grid dispersion constraints. This ensures search directionality while maintaining solution diversity.
1. Pareto非支配解维护（ArchiveManager）
支配关系判断：可以判断两个解在双目标最大化问题下，哪个支配哪个（dominates函数）。

存档更新与非支配筛选：每次迭代根据Pareto支配关系，筛选出新的非支配解集，替换旧的存档（update函数）。

拥挤距离维护多样性：当非支配解数量超过存档容量时，自动计算拥挤距离，优先保留空间上分散的个体（calculate_crowding_distance函数）。

超体积（Hypervolume）计算：能够计算整个精英存档相对于参考点的Hypervolume指标，用于衡量Pareto前沿的质量（calculate_hypervolume函数）。

存档快照输出：可以随时取出当前精英存档，用于可视化或进一步分析（get_archive函数）。

2. 区域引导式Leader选择（LeaderManager）
目标归一化处理：自动将不同尺度的目标值（传播性和公平性）归一化到[0,1]区间，使区域划分稳定可靠（normalize_costs函数）。

三角区域分类：将归一化的目标空间划分为传播优先区域（Spread Zone）、公平优先区域（Fair Zone）和折中区域（Middle Zone）（classify_region函数）。

分区域选择Leader：

在每个区域内挑选传播值最大的解作为代表；

确保搜索能够朝向传播最大化、公平最大化、折中探索三个方向同时推进（select_leaders_by_region函数）。

补全机制：

如果某些区域没有个体，会自动从全局传播值高的解中补充，保证始终有3个Leader可供搜索引导（ensure_leader_minimum函数）。

